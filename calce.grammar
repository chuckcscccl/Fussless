# F# version

!//this is injected verbatim into the generated parser
!type expr = Val of int | Var of string | Float of float | Plus of expr*expr | Times of expr*expr | Minus of expr*expr | Divide of expr*expr | Negative of expr | Letexp of string*expr*expr | Equals of (expr*expr);;

valuetype Vec<expr>
nonterminal E expr
nonterminal ES
terminals + - * / ( ) == = ;
terminals let in
valueterminal Val ~ int ~ Num ~ int
valueterminal Var ~ string ~ Alphanum ~ (fun x -> x)
valueterminal Float ~ float ~ Float ~ float
topsym ES
resync ;

left * 500
left / 500
left + 400
left - 400
nonassoc = 200
right == 300

# Rules
E --> Val:m { Val(m) }
E --> Var:s { Var(s) }
E --> Float:f { Float(f) }
E --> let Var:x = E:e in E:b {Letexp(x,e,b)}
E --> E:e1 + E:e2 { Plus(e1,e2) }
E --> E:e1 - E:e2 { Minus(e1,e2) }
E --> E:e1 * E:e2 { Times(e1,e2) }
E --> E:e1 / E:e2 { Divide(e1,e2) }
E --> E:e1 == E:e2 { Equals(e1,e2) }
E(600) --> - E:e { Negative(e) }
E --> ( E:e )  { e }
#ES --> E:e ; { let v = Vec<expr>() in (v.Add(e); v) }
#ES --> ES:es  E:e ;  { (es.Add(e); es) }
#Esemi --> E:e ; { e }
#ES --> Esemi+:v { v }
#ES --> (E ;)+:v { v }
ES --> E<;+>:v ;? { v }
EOF
